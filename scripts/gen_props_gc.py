import rdkit, numpy as np, sklearn, os, pickle, dscribe, random
from rdkit import Chem
from rdkit.Chem import AllChem
from math import sin, cos
from rdkit.Chem.rdForceFieldHelpers import MMFFGetMoleculeForceField
from rdkit.Chem.rdForceFieldHelpers import MMFFGetMoleculeProperties
from rdkit.ForceField.rdForceField import ForceField

#These dictionaries pair element type and atom hybridization to integers
#for one-hot encoding.
atomdict = {'S':0, 'O':1, 'P':2, 'C':3, 'H':4, 'N':5, 'F':6}
hybrid_dict = {'SP':0, 'SP2':1, 'SP3':2, 'SP3D':3, 'SP3D2':4, 'S':5}

#atomprops generates part of the feature vector for an atom. It takes as input the molecule object
#from rdkit, the id of the current atom,
#a force field generated by rdkit, the id of the hydrogen atom in the coupling pair,
#the id of the non-hydrogen atom in the coupling pair (or the other hydrogen if both are
#hydrogens), the distance matrix for the molecule, the vector of partial charges for
#all the atoms in the molecule and several boolean values to indicate 1) is the current atom
#in between the two coupling partners, 2) is it one of the coupling partners and 3)
#what's the id of the atom between the two coupling partners(useful for 2-bond couplings).

def atomprops(mol, ff, atomid, h_id, het_id, distmat, molcharges, 
              is_center = False, is_coupled_atom = False, center_atom_id = None):
    idx1 = mol.GetAtomWithIdx(atomid)
    num_hydrogens = idx1.GetTotalNumHs(includeNeighbors=True)
    hybridization = hybrid_dict[str(idx1.GetHybridization())]
    atom_arr = np.zeros((58))
    #The first 13 spaces in the feature vector go to one-hot encoding of element and
    #atom hybridization.
    atom_arr[atomdict[idx1.GetSymbol()]] = 1.0
    atom_arr[hybridization+7] = 1.0
    #Element 13 is a one-hot encoding to indicate whether or not the atom is "aromatic"
    #(i.e. part of a certain type of ring). This has a large effect on coupling constants.
    if idx1.GetIsAromatic() == True:
        atom_arr[13] = 1.0
    #Next, store partial charges for this atom calculated using two different methods
    #and the distance between this current atom and the coupling partners. If this
    #current atom IS one of the coupling partners, obviously that distance will be 0.
    atom_arr[14] = molcharges[atomid]
    atom_arr[15] = idx1.GetProp('_GasteigerCharge')
    atom_arr[16] = distmat[atomid, h_id]
    atom_arr[17] = distmat[atomid, het_id]
    neighbor_ids = [x.GetIdx() for x in idx1.GetNeighbors()]
    #One-hot encoding to indicate whether the atom is in a ring and if so what size.
    ringstat = [idx1.IsInRingSize(3), idx1.IsInRingSize(4),
                idx1.IsInRingSize(5), idx1.IsInRingSize(6)]
    for i in range(0,4):
        if ringstat[i] == True:
            atom_arr[20+i] = 1.0
    #In elements 24 through 27, we indicate whether current atom is
    #one of the coupling partners, whether it's a central atom,
    #whether it's attached to the central atom or one of the coupling
    #partners or whether it's elsewhere in the molecule. We'll
    #use this to break hidden layer output down into 4 groups and
    #sum contents of each.
    if is_coupled_atom == True:
        atom_arr[24] = 1.0
    elif is_center == True:
        atom_arr[25] = 1.0
    elif center_atom_id is not None:
        if center_atom_id in neighbor_ids or het_id in neighbor_ids:
            atom_arr[26] = 1.0
    elif het_id in neighbor_ids:
        atom_arr[26] = 1.0
    else:
        atom_arr[27] = 1.0
    #The remaining elements constitute one row of the adjacency matrix.
    for i, neighbor in enumerate(neighbor_ids):
        atom_arr[28+neighbor] = 1.0
    #Set diagonal elements of the adjacency matrix to 1 (equivalent to a loop to self on each vertex).
    atom_arr[28+atomid] = 1.0
    return atom_arr
            
    
#One bond couplings are relatively simple feature-wise, we don't have to consider bond angles
#or atoms in between the partners.
def onebond(mol, ff, conf, atom1id, atom2id, molcharges, distmat):
    output_array = np.zeros((29,58))
    if mol.GetAtomWithIdx(atom1id).GetSymbol() == 'H':
        h_id = atom1id
        het_id = atom2id
    else:
        h_id = atom2id
        het_id = atom1id
    for atomid in range(0, mol.GetNumAtoms()):
        if atomid == h_id or atomid == het_id:
            output_array[atomid,:] = atomprops(mol, ff, atomid, h_id, het_id, distmat,
                                          molcharges, is_coupled_atom=True)
        else:
            output_array[atomid,:] = atomprops(mol, ff, atomid, h_id, het_id, distmat,
                                          molcharges)
    return output_array

#For two bond couplings, we include the sine and cosine of the bond angle in element 22
#and 23, also we designate a center atom (see atomprops above for what changes for the
#center atom).
def twobond(mol, ff, conf, atom1id, atom2id, molcharges, distmat):
    output_array = np.zeros((29,58))
    if mol.GetAtomWithIdx(atom1id).GetSymbol() == 'H':
        h_id = atom1id
        het_id = atom2id
    else:
        h_id = atom2id
        het_id = atom1id
    center_atom1 = mol.GetAtomWithIdx(h_id).GetNeighbors()[0].GetIdx()
    bondangle = rdkit.Chem.rdMolTransforms.GetAngleRad(conf,h_id,
                                                           center_atom1, het_id)
    for atomid in range(0, mol.GetNumAtoms()):
        if atomid == h_id or atomid == het_id:
            output_array[atomid,:] = atomprops(mol, ff, atomid, h_id, het_id, distmat,
                                          molcharges, is_coupled_atom=True)
            output_array[atomid,22] = sin(bondangle)
            output_array[atomid,23] = cos(bondangle)
        elif atomid == center_atom1:
            output_array[atomid,:] = atomprops(mol, ff, atomid, h_id, het_id, distmat,
                                          molcharges, is_center = True)
            output_array[atomid,22] = sin(bondangle)
            output_array[atomid,23] = cos(bondangle)
        else:
            output_array[atomid,:] = atomprops(mol, ff, atomid, h_id, het_id, distmat,
                                          molcharges, center_atom_id = center_atom1)
    return output_array


#For three bond couplings, we record the sine and cosine of the dihedral angle,
#also we designate two center atoms (the two atoms separating the coupling partners).
def threebond(mol, ff, conf, atom1id, atom2id, molcharges, distmat):
    output_array = np.zeros((29,58))
    if mol.GetAtomWithIdx(atom1id).GetSymbol() == 'H':
        h_id = atom1id
        het_id = atom2id
    else:
        h_id = atom2id
        het_id = atom1id
    center_atom1 = mol.GetAtomWithIdx(h_id).GetNeighbors()[0].GetIdx()
    cent_neighbors = [x.GetIdx() for x in mol.GetAtomWithIdx(center_atom1).GetNeighbors()]
    for neighbor in cent_neighbors:
        temp_arr = [x.GetIdx() for x in mol.GetAtomWithIdx(neighbor).GetNeighbors()]
        if het_id in temp_arr:
            center_atom2 = neighbor
            break
    bondangle = rdkit.Chem.rdMolTransforms.GetDihedralRad(conf,h_id,center_atom1,
                                                              center_atom2, het_id)
    for atomid in range(0, mol.GetNumAtoms()):
        if atomid == h_id or atomid == het_id:
            output_array[atomid,:] = atomprops(mol, ff, atomid, h_id, het_id,
                                          distmat, molcharges, is_coupled_atom=True)
        elif atomid == center_atom1 or atomid == center_atom2:
            output_array[atomid,:] = atomprops(mol, ff, atomid, h_id, het_id,
                                          distmat, molcharges, is_center = True)
        else:
            output_array[atomid,:] = atomprops(mol, ff, atomid, h_id, het_id,
                                          distmat, molcharges)
    output_array[h_id,21] = sin(bondangle)
    output_array[het_id,21] = sin(bondangle)
    output_array[center_atom1,21] = sin(bondangle)
    output_array[center_atom2,21] = sin(bondangle)
    output_array[h_id,22] = cos(bondangle)
    output_array[het_id,22] = cos(bondangle)
    output_array[center_atom1,22] = cos(bondangle)
    output_array[center_atom2,22] = cos(bondangle)
    return output_array

#gen_props_charges gets the MMFF molecule properties (didn't end up using this although it
#is potentially useful for some features we didn't use), the partial charges and a distance
#matrix. This information is passed to the appropriate coupling constant function to
#generate the combined feature/adjacency matrix, which is then returned.
def gen_props_charges(molecule, atom1id, atom2id, numbonds):
    ff = MMFFGetMoleculeProperties(molecule)
    conf = molecule.GetConformer(0)
    rdkit.Chem.rdPartialCharges.ComputeGasteigerCharges(molecule)
    molcharges = rdkit.Chem.rdMolDescriptors.CalcEEMcharges(molecule)
    distmat = rdkit.Chem.rdmolops.Get3DDistanceMatrix(molecule)
    if numbonds == 1:
        return onebond(molecule, ff, conf, atom1id, atom2id, molcharges, distmat)
    elif numbonds == 2:
        return twobond(molecule, ff, conf, atom1id, atom2id, molcharges, distmat)
    else:
        return threebond(molecule, ff, conf, atom1id, atom2id, molcharges, distmat)

